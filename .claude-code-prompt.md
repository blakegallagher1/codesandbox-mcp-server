# CodeSandbox MCP Server - Build Specification

## CRITICAL: READ FIRST

This is a **security-sensitive project**. Every implementation decision must prioritize:
1. Input validation (Zod schemas for ALL user inputs)
2. Least privilege (whitelist-based, not blacklist)
3. Immutable audit logging (log before execution)
4. Error sanitization (never leak secrets/paths)
5. Rate limiting & quotas

This is NOT production-deployable until security tests pass.

---

## PROJECT CONTEXT

Build a TypeScript Model Context Protocol (MCP) server that connects ChatGPT/Claude to:
- **CodeSandbox API** (programmatic sandbox creation & code execution)
- **GitHub API** (fine-grained commit/PR workflow)

The server will be deployed as a Docker container and used by Claude/ChatGPT via MCP protocol.

**Key Constraint:** Assume ChatGPT is an untrusted adversary. Every input is potentially malicious.

---

## PHASE 1: PROJECT SETUP (First)

### Create Directory Structure
```
codesandbox-mcp-server/
├── src/
│   ├── index.ts
│   ├── server.ts
│   ├── tools/
│   │   ├── sandbox-tools.ts
│   │   ├── github-tools.ts
│   │   └── index.ts
│   ├── services/
│   │   ├── sandbox-manager.ts
│   │   ├── github-manager.ts
│   │   ├── rate-limiter.ts
│   │   ├── audit-logger.ts
│   │   ├── config.ts
│   │   └── path-validator.ts
│   ├── middleware/
│   │   ├── auth.ts
│   │   ├── validation.ts
│   │   └── error-handler.ts
│   └── types/
│       └── index.ts
├── tests/
│   ├── unit/
│   │   └── path-validator.test.ts
│   ├── integration/
│   │   ├── github-integration.test.ts
│   │   └── sandbox-integration.test.ts
│   └── security/
│       └── security.test.ts
├── .github/
│   └── workflows/
│       └── security.yml
├── .env.template
├── .gitignore
├── Dockerfile
├── docker-compose.yml
├── package.json
├── tsconfig.json
├── jest.config.js
├── SECURITY.md
├── README.md
└── .claude-code-prompt.md
```

### Create package.json
- Dependencies: @modelcontextprotocol/sdk, @codesandbox/sdk, @octokit/rest, zod, pino
- DevDeps: typescript, jest, ts-jest, @types/node, eslint, snyk
- Scripts: build, test, test:security, lint, start, dev
- All versions PINNED (no ^, no ~)

### Create tsconfig.json
- Target: ES2020
- Module: commonjs
- Strict: true
- NoImplicitAny: true
- ResolveJsonModule: true
- Outdir: dist

### Create jest.config.js
- Preset: ts-jest
- TestEnvironment: node
- TestMatch: tests/**/*.test.ts
- Coverage: { lines: 80, branches: 75, functions: 80 }

---

## PHASE 2: TYPES & VALIDATION (Second)

### src/types/index.ts

Create Zod schemas for ALL inputs:

**CreateSandboxInput**
- project_name: string, 1-50 chars, regex /^[a-zA-Z0-9_-]+$/
- template: enum ["react", "next", "vue", "node"]
- initial_files: record of (path → content), max 20 files, 1MB each

**CommitToPushInput**
- repo_id: string (will be validated against allowlist)
- branch: string, regex /^[a-zA-Z0-9._/-]+$/ (no ../ or //)
- files: record of (path → content), max 10 files, 500KB each
- commit_message: string, max 200 chars
- create_pr: boolean optional
- pr_title: string optional, max 100 chars

**WriteFilesInput**
- sandbox_id: string (must be UUID format)
- files: record of (path → content), max 10 files, 500KB each

**GetSandboxOutputInput**
- sandbox_id: UUID format
- output_type: enum ["console_log", "build_output", "preview_url"]

**ReadGitHubFileInput**
- repo_id: string
- file_path: regex /^[a-zA-Z0-9._/-]+$/
- branch: string, default "main"

All schemas export as `export type XInput = z.infer<typeof XSchema>;`

---

## PHASE 3: ERROR HANDLING (Third)

### src/middleware/error-handler.ts

**MCPError class**
- code: string (enum from ERROR_CODES)
- message: string
- statusCode: number
- retryable: boolean

**ERROR_CODES enum**
- INVALID_REPO
- SANDBOX_NOT_FOUND
- GITHUB_AUTH_FAILED
- RATE_LIMIT_EXCEEDED
- INVALID_BRANCH
- PATH_TRAVERSAL
- TOKEN_EXPIRED
- SANDBOX_TIMEOUT
- FILE_SIZE_EXCEEDED
- QUOTA_EXCEEDED
- PERMISSION_DENIED

**executeWithErrorHandling function**
- Wraps all tool execution
- Catches errors, logs sanitized version
- Re-throws MCPError unchanged
- Converts unknown errors to generic "internal error"

**sanitizeErrorMessage function**
- Replace /token|secret|api[_-]?key|password/gi with [REDACTED]
- Replace /\/home\/\S+/g with /[USER]/
- Max 200 chars

**sanitizeParameters function** (for logging)
- Remove token/secret fields from logged parameters
- Replace with [REDACTED]

---

## PHASE 4: CONFIG MANAGEMENT (Fourth)

### src/services/config.ts

**ConfigSchema** (Zod)
- mcp_port: positive int
- csb_api_key: non-empty string
- csb_workspace_id: non-empty string
- rate_limit_per_minute: positive int
- sandbox_idle_timeout_ms: positive int
- max_sandbox_age_ms: positive int
- github_token_map: record of repo_id → token (string)

**ConfigManager class**
- loadFromEnv(): parse all env vars with ConfigSchema
- If validation fails: log error, call process.exit(1)
- get(key: keyof Config): return value

**Export singleton** `export const config = new ConfigManager();`

---

## PHASE 5: VALIDATION & SECURITY (Fifth)

### src/services/path-validator.ts

**validateFilePath function**
- Return false if includes ".."
- Return false if starts with "/"
- Return false if matches FORBIDDEN_PATHS regex array:
  - /^\.env/
  - /^\.git/
  - /^node_modules/
  - /^\.codesandbox/
  - /^\/etc/
  - /^\/root/
- Return true otherwise

**validateBranchName function**
- regex /^[a-zA-Z0-9._/-]+$/
- No spaces, no special chars

**validateRepoId function**
- Must exist in ALLOWED_REPOS config
- Must be a string key

### src/services/rate-limiter.ts

**RateLimiter class**
- Constructor takes rate_limit_per_minute from config
- checkLimit(userId: string, tier: "free" | "pro"): boolean
- Returns false if limit exceeded for current minute
- Internal Map: userId:operation → { count, reset_at }
- Reset window every 60 seconds

**Quota tiers** (hardcoded):
- free: 5 sandboxes/hour, 10 API calls/min, 1 hour execution/day
- pro: 100 sandboxes/hour, 100 API calls/min, 24 hours execution/day

---

## PHASE 6: AUDIT LOGGING (Sixth)

### src/services/audit-logger.ts

**AuditLog interface**
- timestamp: ISO string
- user_id: string
- tool_name: string
- parameters: sanitized object
- result: "success" | "failure" | "rate_limited"
- error?: string
- sandbox_id?: string
- execution_time_ms: number
- hash: SHA256 hash of log entry (for integrity)

**AuditLogger class**
- log(entry: AuditLog): write to SQLite (local file for now)
- All writes append-only (no updates)
- On failure, alert security team (console.error for now, can be webhook)

**Export singleton** `export const auditLogger = new AuditLogger();`

---

## PHASE 7: SERVICE MANAGERS (Seventh)

### src/services/sandbox-manager.ts

**SandboxManager class**
- Wraps CodeSandbox SDK
- Methods:
  - createSandbox(input: CreateSandboxInput, userId: string): Promise<{sandbox_id, preview_url}>
  - writeFiles(sandbox_id, files, userId): Promise<void>
  - getSandboxOutput(sandbox_id, output_type, userId): Promise<string>
  - getAllSandboxes(userId): Promise<SandboxMetadata[]>

**createSandbox implementation**
- Validate input with schema
- Set resource limits: 512MB RAM, 50% CPU, 2min timeout
- Set TTL: 1 hour (auto-destroy)
- Return sandbox_id + preview_url
- Log to audit

**writeFiles implementation**
- Validate all file paths with validateFilePath
- Check total size doesn't exceed quota
- Write files to sandbox
- Log to audit

**getSandboxOutput implementation**
- Filter output (sanitize secrets, truncate to 50KB)
- Return only safe content
- Log to audit

### src/services/github-manager.ts

**GitHubManager class**
- Wraps Octokit
- Methods:
  - commitAndPush(input: CommitToPushInput, userId): Promise<{success, pr_url?}>
  - readFile(input: ReadGitHubFileInput, userId): Promise<{content, size}>
  - validateTokenPermissions(repo_id): Promise<boolean>

**commitAndPush implementation**
- Validate repo_id exists in ALLOWED_REPOS
- Validate branch is in allowedBranches for that repo
- Validate all file paths
- Get Octokit instance with repo-specific token
- Verify token has push permissions (call repos.get, check permissions.push)
- For each file: createOrUpdateFileContents
- If create_pr: create PR with fixed base branch ("main" or "develop")
- Log to audit
- Return { success: true, pr_url }

**readFile implementation**
- Validate repo_id & file_path
- Get file content
- Return { content, size }
- Read-only, safe

**validateTokenPermissions implementation**
- Call octokit.rest.users.getAuthenticated()
- Verify token is not classic (check scopes)
- Return true if valid

---

## PHASE 8: MCP TOOLS (Eighth)

### src/tools/sandbox-tools.ts

**Tool 1: create_sandbox_for_project**
- Parameters: CreateSandboxInputSchema
- Execute: call sandboxManager.createSandbox()
- Wrap with executeWithErrorHandling
- Wrap with rateLimiter.checkLimit
- Log to audit
- Annotations: readOnlyHint=false, idempotentHint=false

**Tool 2: write_files_to_sandbox**
- Parameters: WriteFilesInputSchema
- Execute: call sandboxManager.writeFiles()
- Same wrapper pattern

**Tool 3: get_sandbox_output**
- Parameters: GetSandboxOutputInputSchema
- Execute: call sandboxManager.getSandboxOutput()
- Annotations: readOnlyHint=true, idempotentHint=true

### src/tools/github-tools.ts

**Tool 4: commit_and_push_to_github**
- Parameters: CommitToPushInputSchema
- Execute: call githubManager.commitAndPush()
- Wrap with executeWithErrorHandling, rateLimiter, audit

**Tool 5: read_github_file**
- Parameters: ReadGitHubFileInputSchema
- Execute: call githubManager.readFile()
- Annotations: readOnlyHint=true, idempotentHint=true

### src/tools/index.ts

Export all tools as array:
```typescript
export const ALL_TOOLS = [
  create_sandbox_for_project,
  write_files_to_sandbox,
  get_sandbox_output,
  commit_and_push_to_github,
  read_github_file,
];
```

---

## PHASE 9: MCP SERVER SETUP (Ninth)

### src/server.ts

**Initialize FastMCP**
```typescript
const server = new FastMCP({
  name: "CodeSandbox Secure Gateway",
  version: "1.0.0",
});
```

**Add all tools** from ALL_TOOLS array with withSecurityMiddleware

**Add health resource**
- URI: health://check
- Returns JSON with status, uptime, timestamp
- Calls checkCSBConnectivity() and checkGitHubConnectivity()

**Export** `export { server };`

---

## PHASE 10: ENTRY POINT (Tenth)

### src/index.ts
```typescript
import { server } from "./server";

const port = config.get("mcp_port");

server.connect(new StdioServerTransport()).then(() => {
  console.log(`MCP server running on port ${port}`);
}).catch((err) => {
  console.error("Failed to start server:", sanitizeErrorMessage(err.message));
  process.exit(1);
});

// Graceful shutdown
process.on("SIGTERM", () => {
  console.log("Shutting down gracefully...");
  process.exit(0);
});
```

---

## PHASE 11: DOCKER & DEPLOYMENT (Eleventh)

### Dockerfile
- Base: node:20-alpine
- RUN npm ci --only=production
- RUN npm run build
- RUN addgroup -g 1001 nodejs && adduser -S nodejs -u 1001
- USER nodejs
- EXPOSE 3000
- HEALTHCHECK: GET /health every 30s
- CMD: ["node", "dist/index.js"]

### docker-compose.yml
- Service: mcp-server
- Build: .
- Ports: 3000:3000
- Environment: all from .env
- Volumes: ./logs:/app/logs
- Restart: unless-stopped
- Network: mcp-net (bridge)

### .env.template
```
MCP_PORT=3000
CSB_API_KEY=your_codesandbox_api_token_here
CSB_WORKSPACE_ID=your_workspace_id
CSB_GITHUB_TOKEN_REPO_1=github_pat_xxx
CSB_GITHUB_TOKEN_REPO_2=github_pat_yyy
RATE_LIMIT_PER_MINUTE=10
SANDBOX_IDLE_TIMEOUT_MS=600000
LOG_LEVEL=info
AUDIT_LOG_LEVEL=info
```

---

## PHASE 12: TESTING (Twelfth)

### tests/unit/path-validator.test.ts
- Test validateFilePath rejects "..", "/", forbidden paths
- Test validateFilePath accepts valid paths
- Test validateBranchName accepts/rejects patterns

### tests/integration/github-integration.test.ts
- Test commitAndPush with valid input succeeds
- Test commitAndPush with non-whitelisted branch fails
- Test readFile succeeds
- Test token validation detects missing permissions

### tests/integration/sandbox-integration.test.ts
- Test createSandbox succeeds
- Test writeFiles succeeds
- Test getSandboxOutput filters secrets

### tests/security/security.test.ts
- Test sanitizeErrorMessage removes secrets
- Test sanitizeParameters removes sensitive fields
- Test path traversal attempts are blocked
- Test oversized files are rejected
- Test rate limiting works per user
- Test quota enforcement works

All tests must have >80% coverage.

---

## PHASE 13: SECURITY FILES (Thirteenth)

### SECURITY.md
```markdown
# Security Policy

## Reporting Vulnerabilities

Email: security@your-domain.com

## Threat Model

See main README for threat model.

## Known Limitations

- Fine-grained PATs expire after 90 days
- No support for organization-level access yet
- Sandboxes auto-destroy after 1 hour
```

### README.md
Include:
- Quick start (3 steps)
- Setup (CodeSandbox API token, GitHub fine-grained PATs)
- Deployment (docker-compose up)
- How to create fine-grained PATs (step-by-step)
- Architecture diagram (ASCII)
- Environment variables documented
- Troubleshooting section
- Security considerations section

### .gitignore
```
.env
.env.local
node_modules/
dist/
build/
*.log
logs/
.DS_Store
.vscode/
.idea/
```

---

## PHASE 14: CI/CD PIPELINE (Fourteenth)

### .github/workflows/security.yml
- Trigger: push, pull_request
- Steps:
  1. Checkout
  2. Setup Node 20
  3. npm ci
  4. npm run test:security (audit + snyk)
  5. npm run build (type check)
  6. npm test (jest)
  7. Upload coverage to codecov

---

## VALIDATION CHECKLIST

Before completing, verify:

- [ ] All Zod schemas defined (no unvalidated inputs)
- [ ] All errors sanitized (no secrets in logs)
- [ ] All paths validated (no traversal)
- [ ] Rate limiting on all tools
- [ ] Audit logging immutable (append-only)
- [ ] GitHub tokens are fine-grained PATs only
- [ ] Repository access is whitelist-based
- [ ] All tests pass (>80% coverage)
- [ ] Docker builds without warnings
- [ ] Health check endpoint works
- [ ] Security audit passes (snyk + npm audit)
- [ ] .env.template has all required vars
- [ ] README has complete setup instructions

---

## BUILD STRATEGY FOR CLAUDE CODE

1. Start with PHASE 1 (project setup)
2. Build in order through PHASE 14
3. After each phase, verify files exist and syntax is correct
4. Run `npm run build` after PHASE 10
5. Run `npm test` after PHASE 12
6. Run `npm run test:security` after PHASE 13
7. Build Docker image after PHASE 14
8. Do NOT skip phases

---

## CRITICAL REMINDERS

- **NEVER** accept arbitrary shell commands from MCP inputs
- **NEVER** use process.env directly (use ConfigManager)
- **NEVER** log unfiltered parameters (always sanitize)
- **NEVER** create tokens with broad permissions (fine-grained PATs only)
- **NEVER** trust file paths (always validate with regex + blacklist)
- **NEVER** return full error messages to client (sanitize)
- **Always** assume ChatGPT is an untrusted adversary
- **Always** whitelist before blacklist
- **Always** log before execution
- **Always** use immutable audit logs

---

## SUCCESS CRITERIA

Project is complete when:
1. ✅ All 14 phases implemented
2. ✅ All tests pass (>80% coverage)
3. ✅ Docker builds & runs without errors
4. ✅ Health check returns 200 OK
5. ✅ Security audit passes (snyk, npm audit)
6. ✅ All Zod schemas validate inputs
7. ✅ All errors sanitized
8. ✅ README complete with setup instructions
9. ✅ .env.template complete
10. ✅ Git history clean (no secrets committed)

Do NOT deploy to production until all criteria met.
